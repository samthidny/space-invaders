<html>

<head>
    <meta charset="utf-8" />
    <style>
        body {
            color: green;
        }


        [screen-container] {
            display: flex;
            width: 100vw;
            height: 100vh;
            background-color: #333333;
            align-items: center;
            justify-content: center;
        }


        [screen] {
            background-color: black;
        }

        [game-header] {}


        [game-canvas-container] {
            height: 500px;
        }


        [game-footer] {
            background-color: #666;
        }

        [game-canvas] {
            position: absolute;
            height: 500px;
        }

        [sprite] {
            position: absolute;
        }

        [enemy]::before {
            content: "\1F47E";
            font-size: 1.5em;
        }

        [tank] {
            background-color: green;
            color: white;
        }

        [shield] {
            background-color: green;
            border: none;
        }

        [missile] {
            background-color: yellow;

        }

        [bomb] {
            background-color: red;
        }

        [mystery-ship] {
            background-color: red;
        }
    </style>

</head>

<body>

    <div screen-container>
        <div screen>
            <div game-header>
                <div>SCORE: <span score-text>0</span></div>
                <div>DEBUG: <span debug-text>xxx</span></div>
                
                <button onclick="start()">Play</button>
                <button onclick="stop()">Pause</button>
                <button onclick="nextLevel()">Next Level</button>

            </div>
            <!-- Game container takes up the space as game-canvas is absolute -->
            <div game-canvas-container>
                <div game-canvas>
                    Game
                </div>
            </div>
            <div game-footer>
                <h3>Footer</h3>
            </div>
        </div>
    </div>
</body>


<script>

    const GAME_WIDTH = 500;
    const GAME_HEIGHT = 500;
    const DEFAULT_SPRITE_SIZE = 32;

    const TANK_SPEED = 2;

    const NUM_ENEMY_ROWS = 5;
    const ENEMY_SIZE = 24;
    const ENEMY_X_SPACE = 17;
    const ENEMY_Y_SPACE = 15;
    const ENEMY_GROUND_LIMIT = 370;

    const MISSILE_SPEED = 6;
    const MISSILE_WIDTH = 1;
    const MISSILE_HEIGHT = 6;

    const BOMB_SPEED = 3;
    const MAX_BOMBS = 1;

    const SHIELD_WIDTH = 60;
    const SHIELD_HEIGHT = 40;


    const debug = (str) => {
        document.querySelector('[debug-text]').innerText = str;
    }

    class GameItem {

        constructor(type, x, y, width, height, metadata) {
            this.type = type;
            this.x = x;
            this.y = y;
            this.width = width || DEFAULT_SPRITE_SIZE;
            this.height = height || DEFAULT_SPRITE_SIZE;
            this.isAlive = true;
            this.metadata = metadata;
        }

    }

    class GameModel {

        constructor() {
            this.sprites = [];
            this.numSprites = 0;
            this.gameWidth = GAME_WIDTH;
            this.gameHeight = GAME_HEIGHT;
        }

        addSprite(gameItem) {
            this.sprites.push(gameItem);
            gameItem.id = 'item' + this.numSprites;
            this.numSprites++;
            return gameItem;
        }

    }


    class Renderer {

        constructor(model) {
            this.model = model;
            //this.itemToSprite = {};
            // this.init();
        }

        clear() {
            const canvas = document.querySelector('[game-canvas]');
            canvas.innerHTML = '';

        }

        init() {

            // Style DIVS
            // debugger;
            //document.querySelector('[screen]').style.setProperty('width', `${this.model.gameWidth}px`)

            document.querySelector('[game-canvas]').style.setProperty('width', `${this.model.gameWidth}px`)
            // Create div sprites


            document.querySelector('[screen]').style.setProperty('width', `${this.model.gameWidth}px`)

            this.model.sprites.forEach((gameItem) => {
                this.addSprite(gameItem);
                //this.itemToSprite[gameItem] = e;
            })
        }

        addSprite(gameItem) {
            const gameDiv = document.querySelector('[game-canvas]')
            const e = document.createElement('div');
            e.setAttribute('sprite', true);
            e.setAttribute('itemID', gameItem.id);
            e.setAttribute(gameItem.type, true);

            for (let prop in gameItem.metadata) {
                e.setAttribute(prop, gameItem.metadata[prop]);
            }

            // Set size in css
            e.style.width = `${gameItem.width}px`;
            e.style.height = `${gameItem.height}px`;


            //e.innerText = gameItem.type;
            gameDiv.appendChild(e);
            return e;
        }

        removeSprite(gameItem) {
            const sprite = gameDiv.querySelector(`[itemID="${gameItem.id}"]`) || this.addSprite(gameItem);
            //sprite.style.left = 2000 + 'px';
        }

        render() {
            const gameDiv = document.querySelector('[game-canvas]')
            this.model.sprites.forEach((gameItem) => {
                const sprite = gameDiv.querySelector(`[itemID="${gameItem.id}"]`) || this.addSprite(gameItem);
                sprite.style.left = gameItem.x + 'px';
                sprite.style.top = gameItem.y + 'px';
                sprite.innerText = gameItem[gameItem?.debugData] || '';

                // Temp hide dead sprites
                if (!gameItem.isAlive) {
                    sprite.style.display = 'none';
                }

            })



            document.querySelector('[game-footer]').innerText = `LIVES: ${this.model.lives}`;
            document.querySelector('[score-text]').innerText = `${this.model.score}`;


        }

    }


    class KeyboardManager {


        constructor() {
            document.addEventListener('keydown', (event) => this.keyDownHandler(event));
            document.addEventListener('keyup', (event) => this.keyUpHandler(event));

            this.keyDown = {};
        }

        keyDownHandler(event) {
            event.preventDefault()
            this.keyDown[event.code] = true;
        }

        keyUpHandler(event) {
            event.preventDefault()
            this.keyDown[event.code] = false;
        }

    }


    class Game {

        constructor() {

        }

        init() {
            this.gameLoopsPerSecond = 100;
            this.isPaused = true;
            this.frameCount = 0;
            this.gameInProgress = false;
            this.gameIsOver = false;
            this.keyboard = new KeyboardManager();

            this.model = new GameModel();

            this.interval = null;
            this.renderer = new Renderer(this.model);


            // Initial game values
            this.model.lives = 3;
            this.model.score = 0;
            this.enemyStaggerFrequency = 20;
            this.maxActiveBombs = 1;

            this.enemyStartY = 50;
            this.enemySpeedUpActivated = false;

            this.initLevel()

            // Fire missile
            document.addEventListener('keyup', (event) => {
                if (event.code == 'Space' && this.numActiveMissiles === 0) {
                    this.fireMissile = true;
                    this.numActiveMissiles++;
                }
            });

            this.renderer.clear();
            this.renderer.init();

        }

        // Just resets the game without clearing game model data
        initLevel() {

            this.model.sprites = [];
            this.renderer.clear()

            // Space Invaders Specific Stuff

            this.currentEnemyRow = NUM_ENEMY_ROWS;
            this.numActiveMissiles = 0;
            this.numActiveBombs = 0;


            // Create Enemies
            for (var y = 0; y < NUM_ENEMY_ROWS; y++) {
                for (var x = 0; x < 11; x++) {
                    this.model.addSprite(new GameItem('enemy', (ENEMY_SIZE + ENEMY_X_SPACE) * x, ((ENEMY_SIZE + ENEMY_Y_SPACE) * y) + this.enemyStartY, ENEMY_SIZE, ENEMY_SIZE, { column: x, row: y }));
                }
            }

            const createShield = (xPos, yPos) => {
                for (let y = 0; y < 5; y++) {
                    for (let x = 0; x < 6; x++) {
                        const blockSize = 10;
                        const skip = y === 4 && x > 1 && x < 4;
                        if (!skip) {
                            this.model.addSprite(new GameItem('shield', xPos + (blockSize * x), yPos + (blockSize * y), blockSize, blockSize));
                        }
                    }
                }
            }


            // Create shields
            for (var x = 0; x < 4; x++) {
                createShield(50 + (SHIELD_WIDTH * x) + (50 * x), 400);
            }

            this.enemyDirection = 1;
            this.enemySpeed = 6;
            this.enemyStaggerFrequency = 20;
            this.moveEnemyCount = 0;

            // Create Tank
            this.tank = this.model.addSprite(new GameItem('tank', this.model.gameWidth / 2, this.model.gameHeight - DEFAULT_SPRITE_SIZE));
            this.tankSpeed = TANK_SPEED;
            this.fireMissile = false;
        }

        levelComplete() {
            // TODO - Add game over restart from scratch
            alert('LEVEL COMPLETE');
            // this.stop();
            this.nextLevel();
            // this.start();
        }

        gameOver() {
            console.log('GAME OVER');
            this.stop();
        }

        start() {
            if (this.gameInProgress) {
                return;
            }
            this.isPaused = false;
            this.gameInProgress = true;
            this.renderer.render();
            this.interval = setInterval(() => {
                this.gameLoop()
            }, Math.round(1000 / this.gameLoopsPerSecond));
            // this.animationFrameGameLoop()
        }

        stop() {
            this.isPaused = true;
            // clearInterval(this.interval);
            this.gameInProgress = false;
        }

        speedUpEnemyMovement() {
            this.enemyStaggerFrequency -= 2;
            console.log('New Stagger Frequency', this.enemyStaggerFrequency)
            if (this.enemyStaggerFrequency < 1) {
                this.enemyStaggerFrequency = 1;
            }
        }

        nextLevel() {
            // Set things like speed, num Missiles etc here
            //this.speedUpEnemyMovement();
            //this.maxActiveBombs++;

            this.enemyStartY += 5;
            this.initLevel();
        }

        animationFrameGameLoop() {
            if (this.gameInProgress) {
                requestAnimationFrame(() => {
                    this.gameLoop();
                })
            }
        }

        gameLoop() {

            this.frameCount++;

            const getLiveItems = (type) => {
                return this.model.sprites.filter(gameItem => gameItem.type === type && gameItem.isAlive)
            }

            let enemiesHitWall = false;

            // Move all sprites before calculating anything


            // Move Tank
            if (this.keyboard.keyDown['ArrowRight']) {
                this.tank.x += this.tankSpeed;
            }

            if (this.keyboard.keyDown['ArrowLeft']) {
                this.tank.x -= this.tankSpeed;
            }

            // Create Missile
            if (this.fireMissile) {
                this.model.addSprite(new GameItem('missile', this.tank.x + (this.tank.width * 0.5), this.tank.y, MISSILE_WIDTH, MISSILE_HEIGHT));
                this.fireMissile = false;
            }

            debug(this.numActiveBombs + ', ' + this.maxActiveBombs)
            
            // Create Enemy Bomb
            if (this.fireBomb && this.firingEnemy && this.numActiveBombs < this.maxActiveBombs) {
                this.model.addSprite(new GameItem('bomb', this.firingEnemy.x + (DEFAULT_SPRITE_SIZE * 0.5), this.firingEnemy.y + (DEFAULT_SPRITE_SIZE * 0.5), 2, 20));
                this.fireBomb = false;
                this.numActiveBombs++;
                this.firingEnemy = null;
            }

            if (this.fireMysteryShip) {
                this.model.addSprite(new GameItem('mystery-ship', 0, 10, 40, 10));
                this.fireMysteryShip = false;
            }

            const enemies = getLiveItems('enemy');
            const shields = getLiveItems('shield');
            const mysteryShips = getLiveItems('mystery-ship');


            if (enemies.length === 0) {
                this.nextLevel();
            }

            // Move enemies
            // Staggered enemy movement by row
            if (this.moveEnemyCount % this.enemyStaggerFrequency === 0) {
                enemies.forEach(gameSprite => {

                    if (gameSprite.metadata.row === this.currentEnemyRow) {
                        gameSprite.x += (this.enemyDirection * this.enemySpeed);
                    }

                    // TODO - We will need to keep track of min - max rows
                    if (gameSprite.metadata.row === 0) {
                        // Check if hit right wall
                        if (this.enemyDirection > 0 && (gameSprite.x + gameSprite.width) >= this.model.gameWidth) {
                            enemiesHitWall = true;
                        }

                        // Check if hit left wall
                        if (this.enemyDirection < 0 && gameSprite.x <= 0) {
                            enemiesHitWall = true;
                        }
                    }
                })

                // change currentEnemyRow
                this.currentEnemyRow--;
                if (this.currentEnemyRow < 0) {
                    this.currentEnemyRow = NUM_ENEMY_ROWS - 1;
                }

                this.moveEnemyCount = 0;
            }


            // Enemy Bombs

            // Find lowest enemies
            const lowestCols = [];
            enemies.forEach(gameSprite => {
                if (gameSprite.isAlive) {
                    const col = gameSprite.metadata.column;
                    lowestCols[col] = gameSprite;
                }
            })

            // Fire Enemy bombs randomly
            if (Math.floor(Math.random() * 40) === 0) {
                this.fireBomb = true;
                // Pick random enemy
                this.firingEnemy = lowestCols[Math.floor(Math.random() * lowestCols.length - 1)]
            }

            // Random Mystery ship
            if (Math.floor(Math.random() * 100) === 0) {
                if (mysteryShips.length === 0) {
                    this.fireMysteryShip = true;
                }

            }

            const missiles = getLiveItems('missile');
            // Move missiles
            missiles.forEach(gameSprite => {
                gameSprite.y -= MISSILE_SPEED;
            })

            const bombs = getLiveItems('bomb');
            // Move missiles
            bombs.forEach(gameSprite => {
                gameSprite.y += BOMB_SPEED;
            })

            // Move mystery ship
            mysteryShips.forEach(gameSprite => {
                gameSprite.x += 1;
            })

            // Game Logic
            if (enemiesHitWall) {
                this.enemyDirection *= -1;
                enemies.forEach(enemy => {
                    enemy.y += ENEMY_SIZE;
                })
                enemiesHitWall = false;
            }

            const isHit = (a, b) => {
                if (a.x < b.x + b.width && a.x + a.width > b.x) {
                    if (a.y < b.y + b.height && a.y + a.height > b.y) {
                        return true;
                    }
                }
            }


            // COLLISION DETECTION

            // Check if missile has hit an invader
            missiles.forEach(missile => {

                mysteryShips.forEach(mysteryShip => {
                    if (isHit(missile, mysteryShip)) {
                        mysteryShip.isAlive = false;
                        missile.isAlive = false;
                        this.numActiveMissiles--;
                        this.model.score += 1000;
                    }

                })

                enemies.forEach(enemy => {
                    if (isHit(missile, enemy)) {
                        enemy.isAlive = false;
                        missile.isAlive = false;
                        this.numActiveMissiles--;
                        if (enemy.metadata.row > 3) {
                            this.model.score += 10;
                        } else if (enemy.metadata.row > 1) {
                            this.model.score += 20;
                        } else {
                            this.model.score += 30;
                        }

                        if((enemies.length - 1) % 5 === 0) {
                            console.log('SPEED UP!!!!!')
                            this.speedUpEnemyMovement();
                        }
                    }
                })

                shields.forEach(shield => {
                    if (isHit(missile, shield)) {
                        shield.isAlive = false;

                        //enemy.isAlive = false;
                        // shield.strength--;
                        missile.isAlive = false;
                        this.numActiveMissiles--;

                        // if (shield.strength === 0) {

                        // }
                    }
                })

                //Check missile has gone above screen
                if (missile.y < 0) {
                    missile.isAlive = false;
                    this.numActiveMissiles--;
                }
            })


            // Check if bombs has hit tank
            bombs.forEach(bomb => {
                // TODO - create killBomb function so we dont repeat code
                if (isHit(bomb, this.tank)) {
                    bomb.isAlive = false;
                    this.numActiveBombs--;
                    if(this.numActiveBombs < 0) {
                        this.numActiveBombs = 0;
                    }
                    this.tank.lives--;
                    this.model.lives--;
                    // TODO - Tank Hit!!!
                }

                shields.forEach(shield => {
                    if (isHit(bomb, shield)) {
                        bomb.isAlive = false;
                        shield.isAlive = false;
                        this.numActiveBombs--
                    }
                })

                //Check missile has gone below screen
                if (bomb.y > this.model.gameHeight) {
                    bomb.isAlive = false;
                    this.numActiveBombs--;
                }
            })

            // Any enemies hit the ground/shields
            enemies.forEach(enemy => {
                if (enemy.y >= ENEMY_GROUND_LIMIT) {
                    this.gameIsOver = true;
                }
            });

            // Any enemies hit the ground/shields
            mysteryShips.forEach(mysteryShip => {
                if (mysteryShip.x >= GAME_WIDTH) {
                    mysteryShip.isAlive = false;
                }
            });

            this.renderer.render();

            // Increase counters
            this.moveEnemyCount++;

            if(this.model.lives === 0) {
                this.gameIsOver = true;
            }

            if (this.gameIsOver) {
                this.gameOver();
            }

            // if (!this.isPaused && this.gameInProgress) {
            //     this.animationFrameGameLoop();
            // }

            if(this.isPaused || !this.gameInProgress) {
                clearInterval(this.interval);
            }
        }


    }


    const game = new Game();
    game.init();

    function start() {
        game.start();
    }

    function stop() {
        game.stop();
    }

    function nextLevel() {
        game.start();
        game.nextLevel();
    }



</script>



</html>