<html>

<head>
    <meta charset="utf-8" />
    <style>
        body {
            color: green;
            font-family: 'Courier New', Courier, monospace;
        }


        [screen-container] {
            display: flex;
            width: 100vw;
            height: 100vh;
            background-color: #333333;
            align-items: center;
            justify-content: center;
        }


        [screen] {
            background-color: black;
        }

        [game-header] {}


        [game-canvas-container] {
            height: 500px;
        }


        [game-footer] {
            background-color: black;
        }

        [game-canvas] {
            position: absolute;
            height: 500px;
        }

        [sprite] {
            position: absolute;
        }

        [sprite] canvas {
            width: 100%;
            height: 100%;
        }

        /* [enemy]::before {
            content: "\1F47E";
            font-size: 1.5em;
        } */

        [tank] {
            /* background-color: green; */
            color: white;
        }

        [shield] {
            background-color: green;
            border: none;
        }

        [missile] {
            background-color: yellow;

        }

        [bomb] {
            background-color: red;
        }

        [mystery-ship] {
            background-color: red;
        }
    </style>

</head>

<body>

    <div screen-container>
        <div screen>
            <div game-header>
                <div>SCORE: <span score-text>0</span></div>
                <div>DEBUG: <span debug-text>xxx</span></div>

                <button onclick="window.game.start()">Play</button>
                <button onclick="window.game.stop()">Pause</button>
                <button onclick="window.game.nextLevel()">Next Level</button>

            </div>
            <!-- Game container takes up the space as game-canvas is absolute -->
            <div game-canvas-container>
                <div game-canvas>
                    Game
                </div>
            </div>
            <div game-footer>
                <h3>Footer</h3>
            </div>
        </div>
    </div>
</body>


<script type="module" >
    const NUM_LIVES = 3;

    const GAME_WIDTH = 500;
    const GAME_HEIGHT = 500;
    const DEFAULT_SPRITE_SIZE = 32;

    const TANK_SPEED = 1.5;
    const TANK_MARGIN = 20;

    const NUM_ENEMY_ROWS = 5;
    const ENEMY_SPEED = 5;
    const ENEMY_SIZE = 24;
    const ENEMY_X_SPACE = 15;
    const ENEMY_Y_SPACE = 15;
    const ENEMY_SHIELD_LIMIT = 360;
    const ENEMY_GROUND_LIMIT = 400;
    
    const ENEMY_STAGGER_FRAMES_MAX = 50;
    const ENEMY_STAGGER_FRAMES_MIN = 1;
    const ENEMY_LEVEL_INCREASE_Y = 20;
    
    const GAME_LOOPS_PER_SECOND = 100;

    const MISSILE_SPEED = 5;
    const MISSILE_WIDTH = 1;
    const MISSILE_HEIGHT = 6;
    const MAX_ACTIVE_MISSILES = 1;

    const BOMB_SPEED = 2;
    const MAX_BOMBS = 1;

    const SHIELD_WIDTH = 60;
    const SHIELD_HEIGHT = 40;


    const USE_ANIMATION_FRAME = false;


    const debug = (str) => {
        document.querySelector('[debug-text]').innerText = str;
    }


    const SPRITES = {
        TANK:
        {
            colour: 0x00ff00,
            frames: [
                [
                    [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                    [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
                    [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
            ]
        },
        ENEMY1: {
            colour: 0xff0000,
            frames: [
                [
                    [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                    [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
                    [0, 1, 1, 0, 1, 1, 0, 1, 1, 0],
                    [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                    [0, 0, 1, 0, 1, 1, 0, 1, 0, 0],
                    [0, 1, 0, 0, 0, 0, 0, 0, 1, 0],
                    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]
                ],
                [
                    [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                    [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
                    [0, 1, 1, 0, 1, 1, 0, 1, 1, 0],
                    [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                    [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
                    [0, 0, 1, 0, 1, 1, 0, 1, 0, 0],
                    [0, 1, 0, 1, 0, 0, 1, 0, 1, 0]
                ]
            ]
        },
        ENEMY2: {
            colour: 0x00ff00,
            frames: [
                [
                    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
                    [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
                    [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
                    [0, 1, 1, 0, 1, 1, 0, 1, 1, 0],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 1, 0, 1],
                    [0, 0, 0, 1, 0, 0, 1, 0, 0, 0]
                ],
                [
                    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
                    [1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 1, 1, 0, 1, 1, 0, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
                    [0, 1, 0, 0, 0, 0, 0, 0, 1, 0]
                ]
            ]
        },
        ENEMY3: {
            colour: 0x0000ff,
            frames: [
                [
                    [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                    [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [0, 0, 1, 1, 0, 0, 1, 1, 0, 0],
                    [0, 1, 1, 0, 1, 1, 0, 1, 1, 0],
                    [1, 1, 0, 0, 0, 0, 0, 0, 1, 1]
                ],
                [
                    [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                    [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [0, 0, 1, 1, 0, 0, 1, 1, 0, 0],
                    [0, 1, 1, 0, 1, 1, 0, 1, 1, 0],
                    [0, 0, 1, 1, 0, 0, 1, 1, 0, 0]
                ]
            ]
        }


    }






    import { GameItem } from './game-item.js';




    // class GameItem {

    //     constructor(type, x, y, width, height, metadata) {
    //         this.type = type;
    //         this.sprite = type;
    //         this.x = x;
    //         this.y = y;
    //         this.width = width || DEFAULT_SPRITE_SIZE;
    //         this.height = height || DEFAULT_SPRITE_SIZE;
    //         this.isAlive = true;
    //         this.metadata = metadata;
    //         this.halfWidth = width * 0.5;
    //         this.halfHeight = height * 0.5;
    //     }

    // }

    class GameModel {

        constructor() {
            this.sprites = [];
            this.numSprites = 0;
            this.gameWidth = GAME_WIDTH;
            this.gameHeight = GAME_HEIGHT;
            this.uniqueID = 0;
        }

        addSprite(gameItem) {
            this.sprites.push(gameItem);
            gameItem.id = 'item' + this.uniqueID;
            this.numSprites++;
            this.uniqueID++;
            return gameItem;
        }


        // TODO - this made bombs turn into tank sprites?  prob reference thing
        removeDeadSprites() {
            const aliveSprites = this.sprites.filter(gameItem => gameItem.isAlive);
            this.sprites = aliveSprites;
            this.numSprites = aliveSprites.length;
            
        }

    }


    class SpriteAnimation {

        constructor(animation) {
            //this.gameItem = gameItem;
            this._animation = animation;
            this.currentFrame = 0;
        }

        get currentFrameSprite() {
            return this._animation[this.currentFrame];
        }

        nextFrame() {
            this.currentFrame++;
            if (this.currentFrame > this._animation.length - 1) {
                this.currentFrame = 0;
            }
        }
    }


    class SpriteManager {

        constructor() {
            this.spriteImageDatas = {};
            this.sprites = [];
            this.spriteAnimations = {};
            this.frameCount = 0;
        }

        addAnimation(name, spriteData) {
            const arr = [];
            for (let i = 0; i < spriteData.frames.length; i++) {

                const imageData = this.createSpriteImageData(spriteData.frames[i], spriteData.colour);
                arr.push(imageData);

            }
            this.spriteImageDatas[name] = arr;
        }

        getAnimation(name) {

            return this.spriteImageDatas[name];
        }

        // Pairing a gameItem with an animation state
        addAnimationSpriteState(gameItemID, animationName) {

            const animation = this.getAnimation(animationName);

            if (!animation) {
                return;
            }
            const spriteAnimation = new SpriteAnimation(animation);
            this.spriteAnimations[gameItemID] = spriteAnimation;
        }

        // this is always returning tank
        getAnimationSpriteState(gameItemID) {
            const state = this.spriteAnimations[gameItemID];
            if (!state) {
                //console.log('No state found');
                return null;
            } else {
                return state;
            }
            //return this.spriteAnimations[gameItem];
        }


        drawToSprite(canvas, gameItemID) {
            const ctx = canvas.getContext('2d');
            const animationSpriteState = this.getAnimationSpriteState(gameItemID);
            if (!animationSpriteState) {
                return;
            }
            const imageData = animationSpriteState.currentFrameSprite;
            // const imageData = this.spriteImageDatas[gameItem.type][0];
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            ctx.putImageData(imageData, 0, 0);
        }

        createSpriteImageData(spriteData, colour) {
            const spriteWidth = spriteData[0].length;
            const spriteHeight = spriteData.length;
            const spriteImageData = new ImageData(spriteWidth, spriteHeight);



            for (let y = 0; y < spriteHeight; y++) {
                for (let x = 0; x < spriteWidth; x++) {
                    this.setPixel(spriteImageData, x, y, spriteData[y][x] ? colour : null);
                }
            }

            return spriteImageData;
        }


        setPixel(imageData, x, y, color) {
            x = Math.round(x);
            y = Math.round(y);
            const offset = ((y * imageData.width) + x) * 4;
            imageData.data[offset] = (color >> 16);
            imageData.data[offset + 1] = (color >> 8) & 0xff;
            imageData.data[offset + 2] = (color) & 0xff;
            imageData.data[offset + 3] = color === null ? 0 : 0xff;
        }

        update() {
            if (this.frameCount > 10000) {
                for (var prop in this.spriteAnimations) {
                    const spriteAnimation = this.spriteAnimations[prop];
                    // TODO why is there sometimes not a spriteAnimation?
                    if (spriteAnimation) {
                        spriteAnimation.nextFrame();
                    }
                }
                this.frameCount = 0;
            }
            this.frameCount++;
            //debug('frameCount: ' + this.frameCount);
            //console.log('SpriteManager.frameCount', this.frameCount);

        }

    }


    class Renderer {

        constructor(model) {
            this.model = model;
            this.spriteManager = new SpriteManager();
            this.frameCount = 0;
            //this.itemToSprite = {};
            // this.init();
        }

        clear() {
            const canvas = document.querySelector('[game-canvas]');
            canvas.innerHTML = '';

        }

        init() {


            document.querySelector('[game-canvas]').style.setProperty('width', `${this.model.gameWidth}px`)
            document.querySelector('[screen]').style.setProperty('width', `${this.model.gameWidth}px`)


            // Set up sprite data

            // Add sprite animations by name
            this.spriteManager.addAnimation('tank', SPRITES.TANK);
            this.spriteManager.addAnimation('enemy', SPRITES.ENEMY1);
            this.spriteManager.addAnimation('enemy1', SPRITES.ENEMY1);
            this.spriteManager.addAnimation('enemy2', SPRITES.ENEMY2);
            this.spriteManager.addAnimation('enemy3', SPRITES.ENEMY2);
            this.spriteManager.addAnimation('enemy4', SPRITES.ENEMY3);
            this.spriteManager.addAnimation('enemy5', SPRITES.ENEMY3);




            // this.model.sprites.forEach((gameItem) => {
            //     // Set up animation states for each sprite in sprite manager
            //     this.spriteManager.addAnimationSpriteState(gameItem, gameItem.type);
            // })




            this.model.sprites.forEach((gameItem) => {
                this.addSprite(gameItem);
                //this.itemToSprite[gameItem] = e;
            })
        }

        addSprite(gameItem) {

            const gameDiv = document.querySelector('[game-canvas]')
            const e = document.createElement('div');
            e.setAttribute('sprite', true);
            e.setAttribute('itemID', gameItem.id);
            e.setAttribute(gameItem.type, true);

            for (let prop in gameItem.metadata) {
                e.setAttribute(prop, gameItem.metadata[prop]);
            }

            // Set size in css
            e.style.width = `${gameItem.width}px`;
            e.style.height = `${gameItem.height}px`;

            //Add canvas to div
            const c = document.createElement('canvas');
            c.setAttribute('width', gameItem.width);
            c.setAttribute('height', gameItem.height);
            e.appendChild(c);

            this.spriteManager.addAnimationSpriteState(gameItem.id, gameItem.sprite || gameItem.type);

            // if (gameItem.type === 'tank' || gameItem.type === 'enemy') {
            //     this.spriteManager.drawToSprite(c, gameItem.id);
            // }



            //e.innerText = gameItem.type;
            gameDiv.appendChild(e);
            return e;
        }

        removeSprite(gameItem) {
            const sprite = gameDiv.querySelector(`[itemID="${gameItem.id}"]`) || this.addSprite(gameItem);
            //sprite.style.left = 2000 + 'px';
        }

        render(renderCount) {
            const gameDiv = document.querySelector('[game-canvas]')
            this.model.sprites.forEach((gameItem) => {
                const sprite = gameDiv.querySelector(`[itemID="${gameItem.id}"]`) || this.addSprite(gameItem);
                sprite.style.left = gameItem.x + 'px';
                sprite.style.top = gameItem.y + 'px';

                // Move animations on
                // todo - this isnt the place to do this, just a test
                // if(renderCount % 100 === 0) {
                //     this.spriteManager.update();
                // }

                //drawToSprite(canvas, gameItem)
                const c = sprite.querySelector('canvas');
                // this is where the issue is with everything being tank sprites

                // this.frameCount++;

                // if (this.frameCount % 100 == 0) {
                this.spriteManager.update();
                this.spriteManager.drawToSprite(c, gameItem.id);
                // }



                // Temp hide dead sprites
                if (!gameItem.isAlive) {
                    sprite.parentElement.removeChild(sprite);
                    sprite.style.display = 'none';
                }

            })



            document.querySelector('[game-footer]').innerText = `LIVES: ${this.model.lives}`;
            document.querySelector('[score-text]').innerText = `${this.model.score}`;


        }

    }


    class KeyboardManager {


        constructor() {
            document.addEventListener('keydown', (event) => this.keyDownHandler(event));
            document.addEventListener('keyup', (event) => this.keyUpHandler(event));

            this.keyDown = {};
        }

        keyDownHandler(event) {
            event.preventDefault()
            this.keyDown[event.code] = true;
        }

        keyUpHandler(event) {
            event.preventDefault()
            this.keyDown[event.code] = false;
        }

    }


    class Game {

        constructor() {

        }

        init() {
            this.gameLoopsPerSecond = GAME_LOOPS_PER_SECOND;
            this.isPaused = true;
            this.frameCount = 0;
            this.renderCount = 0;
            this.gameInProgress = false;
            this.gameIsOver = false;
            this.keyboard = new KeyboardManager();

            this.model = new GameModel();

            this.interval = null;
            this.renderer = new Renderer(this.model);

            

            // Initial game values
            this.model.lives = NUM_LIVES;
            this.model.score = 0;
            this.enemyStaggerFrequency = ENEMY_STAGGER_FRAMES_MAX;
            this.maxActiveBombs = 1;

            this.enemyStartY = 50;

            this.initLevel()

            // Fire missile
            document.addEventListener('keyup', (event) => {
                if (event.code == 'Space' && this.numActiveMissiles < MAX_ACTIVE_MISSILES) {
                    this.fireMissile = true;
                    this.numActiveMissiles++;
                }
            });

            this.renderer.clear();
            this.renderer.init();

        }

        // Just resets the game without clearing game model data
        initLevel() {

            this.model.sprites = [];
            this.renderer.clear()

            // Space Invaders Specific Stuff

            this.currentEnemyRow = NUM_ENEMY_ROWS;
            this.numActiveMissiles = 0;
            this.numActiveBombs = 0;


            // Create Enemies
            for (var y = 0; y < NUM_ENEMY_ROWS; y++) {
                for (var x = 0; x < 11; x++) {
                    const enemyType = 'enemy' + (y + 1);
                    const enemyGameItem = new GameItem('enemy', (ENEMY_SIZE + ENEMY_X_SPACE) * x, ((ENEMY_SIZE + ENEMY_Y_SPACE) * y) + this.enemyStartY, ENEMY_SIZE, ENEMY_SIZE, { column: x, row: y, sprite: enemyType })
                    enemyGameItem.sprite = enemyType;
                    this.model.addSprite(enemyGameItem);
                }
            }

            const createShield = (xPos, yPos) => {
                for (let y = 0; y < 5; y++) {
                    for (let x = 0; x < 6; x++) {
                        // const blockSize = 10;
                        const blockWidth = 10;
                        const blockHeight = 10;
                        const skip = y === 4 && x > 1 && x < 4;
                        if (!skip) {
                            this.model.addSprite(new GameItem('shield', xPos + (blockWidth * x), yPos + (blockHeight * y), blockWidth, blockHeight));
                        }
                    }
                }
            }


            // Create shields
            for (var x = 0; x < 4; x++) {
                createShield(50 + (SHIELD_WIDTH * x) + (50 * x), 400);
            }

            this.hasShields = true;
            this.removeShields = false;

            this.enemyDirection = 1;
            this.enemySpeed = ENEMY_SPEED;
            this.enemyStaggerFrequency = this.enemyStaggerFrequency = this.calculateEnemyStaggerFrequency(55);
            this.moveEnemyCount = 0;

            // Create Tank
            this.tank = this.model.addSprite(new GameItem('tank', this.model.gameWidth / 2, this.model.gameHeight - DEFAULT_SPRITE_SIZE, 24, 24));
            this.tankSpeed = TANK_SPEED;
            this.fireMissile = false;
        }

        levelComplete() {
            // TODO - Add game over restart from scratch
            alert('LEVEL COMPLETE');
            // this.stop();
            this.nextLevel();
            // this.start();
        }

        gameOver() {
            console.log('GAME OVER');
            this.stop();
        }

        start() {
            if (this.gameInProgress) {
                return;
            }
            this.isPaused = false;
            this.gameInProgress = true;
            this.renderer.render();


            if (USE_ANIMATION_FRAME) {
                this.animationFrameGameLoop()
            } else {
                const intervalSpeed = Math.round(1000 / this.gameLoopsPerSecond);
                console.log('intervalSpeed', intervalSpeed);
                this.interval = setInterval(() => {
                    this.gameLoop();
                    //this.renderLoop();
                }, intervalSpeed);
            }
        }

        stop() {
            this.isPaused = true;
            // clearInterval(this.interval);
            this.gameInProgress = false;
        }


        /*


        Stagger starts at 20 and goes down to 2
        55 aliens

        */


        calculateEnemyStaggerFrequency(numEnemies) {
            // For now hard coding this but needs some kind of "hockey curve" formula getting much faster at the end

            const sectors = [
                [55, 1],
                [50, 0.95],
                [45, 0.9],
                [40, 0.85],
                [35, 0.8],
                [30, 0.75],
                [25, 0.7],
                [20, 0.6],
                [15, 0.5],
                [10, 0.4],
                [9, 0.35],
                [8, 0.3],
                [7, 0.25],
                [6, 0.2],
                [5, 0.15],
                [4, 0.1],
                [3, 0.07],
                [2, 0.05],
                [1, 0.01]   
            ];

            // TODO - ES6/functional way of doing this

            const range = ENEMY_STAGGER_FRAMES_MAX - ENEMY_STAGGER_FRAMES_MIN;

            for(let i = 0; i < sectors.length; i++) {
                if (numEnemies >= sectors[i][0]) {
                    const fraction = sectors[i][1];
                    const stagger = ENEMY_STAGGER_FRAMES_MIN + Math.ceil(fraction * range);
                    console.log('new stagger ', numEnemies, fraction, stagger);
                    return stagger;
                }
            }
        }


        speedUpEnemyMovement() {
            this.enemyStaggerFrequency -= 2;
            console.log('New Stagger Frequency', this.enemyStaggerFrequency)
            if (this.enemyStaggerFrequency < 1) {
                this.enemyStaggerFrequency = 1;
            }
        }

        nextLevel() {
            // Set things like speed, num Missiles etc here
            //this.speedUpEnemyMovement();
            //this.maxActiveBombs++;

            this.enemyStartY += ENEMY_LEVEL_INCREASE_Y;
            this.initLevel();
        }

        animationFrameGameLoop() {
            if (this.gameInProgress) {
                requestAnimationFrame(() => {
                    this.gameLoop();
                })
            }
        }

        gameLoop() {

            //this.frameCount++;

            const getLiveItems = (type) => {
                return this.model.sprites.filter(gameItem => gameItem.type === type && gameItem.isAlive)
            }

            let enemiesHitWall = false;

            // Move all sprites before calculating anything

            const tankWallLeft = TANK_MARGIN;
            const tankWallRight = GAME_WIDTH - (TANK_MARGIN + this.tank.width);

            // Move Tank
            if (this.keyboard.keyDown['ArrowRight']) {
                this.tank.x += this.tankSpeed;
                if(this.tank.x > tankWallRight) {
                    this.tank.x = tankWallRight;
                }
            }

            if (this.keyboard.keyDown['ArrowLeft']) {
                this.tank.x -= this.tankSpeed;
                if(this.tank.x < tankWallLeft) {
                    this.tank.x = tankWallLeft;
                }
            }

            // Create Missile
            if (this.fireMissile) {
                this.model.addSprite(new GameItem('missile', this.tank.x + (this.tank.width * 0.5), this.tank.y, MISSILE_WIDTH, MISSILE_HEIGHT));
                this.fireMissile = false;
            }

            // Create Enemy Bomb
            if (this.fireBomb && this.firingEnemy && this.numActiveBombs < this.maxActiveBombs) {
                this.model.addSprite(new GameItem('bomb', this.firingEnemy.x + (DEFAULT_SPRITE_SIZE * 0.5), this.firingEnemy.y + (DEFAULT_SPRITE_SIZE * 0.5), 2, 20));
                this.fireBomb = false;
                this.numActiveBombs++;
                this.firingEnemy = null;
            }

            if (this.fireMysteryShip) {
                this.model.addSprite(new GameItem('mystery-ship', 0, 10, 40, 10));
                this.fireMysteryShip = false;
            }

            

            const enemies = getLiveItems('enemy');
            const shields = getLiveItems('shield');
            const mysteryShips = getLiveItems('mystery-ship');



            if(this.removeShields) {
                shields.forEach(shield => shield.isAlive = false);
                this.removeShields = false;
                this.hasShields = false;
            }


            if (enemies.length === 0) {
                this.nextLevel();
            }

            // Move enemies
            // Staggered enemy movement by row
            if (this.moveEnemyCount % this.enemyStaggerFrequency === 0) {
                enemies.forEach(gameSprite => {

                    //if (gameSprite.metadata.row === this.currentEnemyRow) {
                        gameSprite.x += (this.enemyDirection * this.enemySpeed);
                    //}

                    // TODO - We will need to keep track of min - max rows
                    // if (gameSprite.metadata.row === 0) {
                        // Check if hit right wall
                        if (this.enemyDirection > 0 && (gameSprite.x + gameSprite.width) >= this.model.gameWidth) {
                            enemiesHitWall = true;
                        }

                        // Check if hit left wall
                        if (this.enemyDirection < 0 && gameSprite.x <= 0) {
                            enemiesHitWall = true;
                        }
                    // }
                })

                // change currentEnemyRow
                this.currentEnemyRow--;
                if (this.currentEnemyRow < 0) {
                    this.currentEnemyRow = NUM_ENEMY_ROWS - 1;
                }

                this.moveEnemyCount = 0;
            }


            // Enemy Bombs

            // Find lowest enemies
            const lowestCols = [];
            enemies.forEach(gameSprite => {
                if (gameSprite.isAlive) {
                    const col = gameSprite.metadata.column;
                    lowestCols[col] = gameSprite;
                }
            })

            // Fire Enemy bombs randomly
            if (Math.floor(Math.random() * 40) === 0) {
                this.fireBomb = true;
                // Pick random enemy
                this.firingEnemy = lowestCols[Math.floor(Math.random() * lowestCols.length - 1)]
            }

            // Random Mystery ship
            if (Math.floor(Math.random() * 100) === 0) {
                if (mysteryShips.length === 0) {
                    this.fireMysteryShip = true;
                }

            }

            const missiles = getLiveItems('missile');
            // Move missiles
            missiles.forEach(gameSprite => {
                gameSprite.y -= MISSILE_SPEED;
            })

            const bombs = getLiveItems('bomb');
            // Move missiles
            bombs.forEach(gameSprite => {
                gameSprite.y += BOMB_SPEED;
            })

            // Move mystery ship
            mysteryShips.forEach(gameSprite => {
                gameSprite.x += 1;
            })

            // Game Logic
            if (enemiesHitWall) {
                this.enemyDirection *= -1;
                enemies.forEach(enemy => {
                    enemy.y += ENEMY_SIZE;
                })
                enemiesHitWall = false;
            }

            const isHit = (a, b) => {
                if (a.x < b.x + b.width && a.x + a.width > b.x) {
                    if (a.y < b.y + b.height && a.y + a.height > b.y) {
                        return true;
                    }
                }
            }


            // COLLISION DETECTION

            // Check if missile has hit an invader
            missiles.forEach(missile => {

                mysteryShips.forEach(mysteryShip => {
                    if (isHit(missile, mysteryShip)) {
                        mysteryShip.isAlive = false;
                        missile.isAlive = false;
                        this.numActiveMissiles--;
                        this.model.score += 1000;
                    }

                })

                enemies.forEach(enemy => {
                    if (isHit(missile, enemy)) {
                        enemy.isAlive = false;
                        missile.isAlive = false;
                        this.numActiveMissiles--;
                        if (enemy.metadata.row > 3) {
                            this.model.score += 10;
                        } else if (enemy.metadata.row > 1) {
                            this.model.score += 20;
                        } else {
                            this.model.score += 30;
                        }

                        // if ((enemies.length - 1) % 5 === 0) {
                        //     console.log('SPEED UP!!!!!')
                        //     this.speedUpEnemyMovement();
                        // }

                        this.enemyStaggerFrequency = this.calculateEnemyStaggerFrequency(enemies.length - 1);
                        // debug('enemyStaggerFrequency ' + this.enemyStaggerFrequency);
                    }
                })

                shields.forEach(shield => {
                    if (isHit(missile, shield)) {
                        shield.isAlive = false;

                        //enemy.isAlive = false;
                        // shield.strength--;
                        missile.isAlive = false;
                        this.numActiveMissiles--;

                        // if (shield.strength === 0) {

                        // }
                    }
                })

                //Check missile has gone above screen
                if (missile.y < 0) {
                    missile.isAlive = false;
                    this.numActiveMissiles--;
                }
            })


            // Check if bombs has hit tank
            bombs.forEach(bomb => {
                // TODO - create killBomb function so we dont repeat code
                if (isHit(bomb, this.tank)) {
                    bomb.isAlive = false;
                    this.numActiveBombs--;
                    
                    this.tank.lives--;
                    this.model.lives--;
                    // TODO - Tank Hit!!!
                }

                shields.forEach(shield => {
                    if (isHit(bomb, shield)) {
                        bomb.isAlive = false;
                        shield.isAlive = false;
                        this.numActiveBombs--
                    }
                })

                //Check missile has gone below screen
                if (bomb.y > this.model.gameHeight) {
                    bomb.isAlive = false;
                    this.numActiveBombs--;
                }

                if (this.numActiveBombs < 0) {
                    this.numActiveBombs = 0;
                }
            })

            // Any enemies hit the ground/shields
            enemies.forEach(enemy => {
                if (this.hasShields && enemy.y >= ENEMY_SHIELD_LIMIT) {
                    // Remove shields
                    this.removeShields = true;

                }
                if (enemy.y >= ENEMY_GROUND_LIMIT) {
                    this.gameIsOver = true;
                }
            });

            // Any enemies hit the ground/shields
            mysteryShips.forEach(mysteryShip => {
                if (mysteryShip.x >= GAME_WIDTH) {
                    mysteryShip.isAlive = false;
                }
            });

            this.renderer.render();

            // Increase counters
            this.moveEnemyCount++;

            if (this.model.lives === 0) {
                this.gameIsOver = true;
            }

            if (this.gameIsOver) {
                this.gameOver();
            }


            if (USE_ANIMATION_FRAME) {
                if (!this.isPaused && this.gameInProgress) {
                    this.animationFrameGameLoop();
                }
            } else {

                if (this.isPaused || !this.gameInProgress) {
                    clearInterval(this.interval);
                }
            }


            // Clean up dead sprites
            this.model.removeDeadSprites();

            debug('Model.numSprites = ' + this.model.numSprites);

        }


        renderLoop() {
            this.renderer.render(this.renderCount);
            this.renderCount++;
            //this.animationFrameGameLoop();
        }


    }


    window.game = new Game();
    window.game.init();

    // function start() {
    //     game.start();
    // }

    // function stop() {
    //     game.stop();
    // }

    // function nextLevel() {
    //     game.start();
    //     game.nextLevel();
    // }



</script>



</html>